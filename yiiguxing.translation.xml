<application>
  <component name="AppStorage">
    <histories>
      <item value="Read bean definitions from the given DOM document and register them with the registry in the given reader context." />
      <item value="Resolve the given location against the given resource loader if this implementation's protocol matches." />
      <item value="Any nested &lt;beans&gt; elements will cause recursion in this method. In order to propagate and preserve &lt;beans&gt; default- attributes correctly, keep track of the current (parent) delegate, which may be null. Create the new (child) delegate with a reference to the parent for fallback purposes, then ultimately reset this.delegate back to its original (parent) reference. this behavior emulates a stack of delegates without actually necessitating one." />
      <item value="Actually load the specified document using the configured DocumentLoader." />
      <item value="the number of bean definitions found" />
      <item value="a single resource with the given name" />
      <item value="Load the bean definitions with the given XmlBeanDefinitionReader." />
      <item value="Load bean definitions into the given bean factory, typically through delegating to one or more bean definition readers." />
      <item value="Configure the bean definition reader with this context's resource loading environment." />
      <item value="Configuration interface to be implemented by most listable bean factories. In addition to {@link ConfigurableBeanFactory}, it provides facilities to analyze and modify bean definitions, and to pre-instantiate singletons." />
      <item value="Validate that all properties marked as required are resolvable: see ConfigurablePropertyResolversetRequiredProperties" />
      <item value="This method is idempotent with respect to the fact it may be called any number of times but will perform replacement of stub property sources with their corresponding actual property sources once and only once." />
      <item value="JSON" />
      <item value="@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest)request; HttpSession ses = req.getSession(); HttpServletResponse resp = (HttpServletResponse)response; String path = req.getContextPath(); req.setCharacterEncoding(&quot;UTF-8&quot;); 登陆放通 if (LoginVerify.isLogin(req)) { chain.doFilter(request, response); return; } String url = req.getRequestURI(); System.out.println(url); 不需要拦截的请求 List&lt;String&gt; filterPath = Lists.newArrayList(); filterPath.add(path + &quot;login&quot;); filterPath.add(path + &quot;register&quot;); filterPath.add(path + &quot;userregister.jsp&quot;); filterPath.add(path + &quot;userlogin.jsp&quot;); filterPath.add(path + &quot;error.jsp&quot;); 没有登陆 路径为空-&gt;跳转登陆 if (StringUtils.isEmpty(url)) {" />
      <item value="Nullable" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2" />
        <entry key="ENGLISH" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1621517925835" />
  </component>
</application>